#!/usr/bin/env python
# CCDCPass by Grant Hernandez for the University of Florida
# No license. Public domain
import random
import sys
import string
import argparse
import math

NAME="CCDCPass"
VERSION="1.0"

# TODO: parameterize this function (i.e min length, max length, etc)
def readWordlist(filename, allowed):
    l = open(filename, 'r').read()

    l = l.split('\n')
    a = []

    allowedSet = set(allowed)
    possibleWords = 0

    # parse the wordlist
    for i in l:
        b = i.split("\t")
        word = b[0]

        # avoid empty words
        if len(word) == 0:
            continue

        # make sure the word doesn't have any disallowed characters
        if len(set(word) - allowedSet) != 0:
            continue

        # assert a minimum length
        if len(word) < 3:
            continue

        # disallow words with just one character repeating
        if len(set(word)) <= 1:
            continue

        possibleWords += 1
        a.append(word)

    return a, possibleWords

def main(args):
    if args.format == "text":
        driver = driver_text
    elif args.format == "latex":
        driver = driver_latex
    else:
        print "invalid driver type"
        return

    title = args.title
    numPassphrase = args.n

    if numPassphrase <= 0:
        print("Invalid word count")
        sys.exit(1)

    # TODO: make these as inputs to the program
    minWords = 2
    maxWords = 4
    minLength = 14
    maxLength = 20

    # seed can be any string or number. it is converted to a single number
    # for usage
    seedString = args.seed
    # TODO: this seed function is COMPLETELY insecure. Can be bruteforced
    # and broken if an attacker knows at least one password
    seedNumber = sum([ord(i) for i in seedString])

    random.seed(seedNumber)

    # read wordlist with some character restrictions
    wordlist, possibleWords = readWordlist(args.wordlist, string.ascii_letters)

    # Write some stats
    sys.stderr.write("Wordlist stats %d/%d words\n" % (len(wordlist), possibleWords))

    if len(wordlist) == 0:
        print "Failed to read wordlist"
        sys.exit(1)

    passphrases = []

    i = 0
    skippedStreak = 0

    while i < numPassphrase:
        w = []

        # notify if the requirements are too strong
        if skippedStreak > 400:
            print("WARNING: could not generate a valid passphrase 10 times in a row")
            sys.exit(1)

        # gogogogo
        for j in range(numWords):
            g = wordlist[random.randint(0, len(wordlist)-1)]
            c = list(g)
            c[0] = c[0].upper()
            g = "".join(c)
            w.append(g)

        # add some numbers
        numNumbers = random.randint(1,3)
        for k, val in enumerate(range(numNumbers)):
            lrange = 0

            # dont start with 0
            if k == 0:
                lrange = 1

            # fire some numbers
            w.append(str(random.randint(lrange, 9)))

        # add some special characters
        numNumbers = random.randint(0,1)
        for k, val in enumerate(range(numNumbers)):
            lrange = 0

            # dont start with 0
            if k == 0:
                lrange = 1

            # fire some numbers
            w.append(str(random.randint(lrange, 9)))

        passphrase = "".join(w)

        # ensure that the passphrase meets our requirements
        if len(passphrase) < minLength or len(passphrase) > maxLength:
            skippedStreak += 1
            continue

        skippedStreak = 0
        i += 1
        passphrases.append(passphrase)

    # send the words to the output driver
    driver(passphrases, title, seedString, args.showseed)

def driver_latex(words, title, seed, showseed):
    output = open('template.tex').read()

    column = r"""\begin{minipage}[t]{.33\textwidth}
		\raggedright
		\begin{enumerate}
                \setcounter{enumi}{@@START@@}
                \itemsep-1em
		@@CONTENT@@
		\end{enumerate}
		\end{minipage}"""

    wordsPerCol = 30
    numColumns = int(math.ceil(float(len(words))/wordsPerCol))

    renderedColumns = []
    for i in range(numColumns):
        if i and i % 3 == 0:
            renderedColumns.append(r"\newpage")

        lindex = i*wordsPerCol
        rindex = min(lindex+wordsPerCol, len(words))
        colWords = words[lindex:rindex]

        lines = []
        for j, v in enumerate(colWords):
            if (j+1) % (10) == 0:
                lines.append("\item " + v + " \\\\[1cm]")
            else:
                lines.append("\item " + v + " \\\\")

        renderedColumn = column.replace("@@CONTENT@@", "\n".join(lines))
        renderedColumn = renderedColumn.replace("@@START@@", str(lindex))
        renderedColumns.append(renderedColumn)

    output = output.replace('@@CONTENT@@', "\n".join(renderedColumns))
    output = output.replace('@@TITLE@@', title)

    if showseed:
        output = output.replace('@@AUTHOR@@',
            "Generated by %s %s with seed `%s'" % (NAME, VERSION, seed))
    else:
        output = output.replace('@@AUTHOR@@',
            "Generated by %s %s" % (NAME, VERSION))

    output = output.replace('UF CCDC Password List', "\n".join(words))

    print output

def driver_text(words, title, seed, showseed):
    for i in words:
        print i

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=NAME + ' ' + VERSION)
    parser.add_argument('seed', help='a password seed value')
    parser.add_argument('title', help='document title')

    parser.add_argument('-n', type=int, help='number of words', required=True)
    parser.add_argument('--wordlist', help='an input wordlist', required=True)
    parser.add_argument('--format', help='output format (\'text\' or \'latex\')', default="text" )
    parser.add_argument('--show-seed',
            dest='showseed', action='store_true',
            help='print the seed in output formats')
    parser.add_argument('--hide-seed',
            dest='showseed', action='store_false',
            help='hide the seed in output formats (default)')
    parser.set_defaults(showseed=False)

    args = parser.parse_args()

    main(args)
